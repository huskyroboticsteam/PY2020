<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Resurgence (PY2022): websocket::WebSocketProtocol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Resurgence (PY2022)
   </div>
   <div id="projectbrief">Codebase for the Husky Robotics 2021-2022 rover Resurgence</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>websocket</b></li><li class="navelem"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html">WebSocketProtocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classwebsocket_1_1WebSocketProtocol-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">websocket::WebSocketProtocol Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Defines a protocol which will be served at an endpoint of a server. This protocol defines several message types, and processes messages of those types, dispatching events to message handlers wherever necessary.  
 <a href="classwebsocket_1_1WebSocketProtocol.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="WebSocketProtocol_8h_source.html">WebSocketProtocol.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a49126d6de1f4566a511d36109ff6abf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html#a49126d6de1f4566a511d36109ff6abf4">WebSocketProtocol</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;protocolPath)</td></tr>
<tr class="memdesc:a49126d6de1f4566a511d36109ff6abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new WebSocket protocol. This object doesn't itself "do" anything, but users should register this object with a server, which will then handle dispatching events.  <a href="classwebsocket_1_1WebSocketProtocol.html#a49126d6de1f4566a511d36109ff6abf4">More...</a><br /></td></tr>
<tr class="separator:a49126d6de1f4566a511d36109ff6abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3869e34982bbc3de61c42c8329a655bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html#a3869e34982bbc3de61c42c8329a655bc">addMessageHandler</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;messageType, const std::function&lt; void(<a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a>)&gt; &amp;callback)</td></tr>
<tr class="memdesc:a3869e34982bbc3de61c42c8329a655bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a message handler for the given message type, if no handler already exists. Messages for this message type will not be validated. If a handler already exists, this method no-ops.  <a href="classwebsocket_1_1WebSocketProtocol.html#a3869e34982bbc3de61c42c8329a655bc">More...</a><br /></td></tr>
<tr class="separator:a3869e34982bbc3de61c42c8329a655bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b3a272e0f735d504c921b04fb56b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html#afb4b3a272e0f735d504c921b04fb56b3">addMessageHandler</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;messageType, const std::function&lt; void(<a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a>)&gt; &amp;callback, const std::function&lt; bool(<a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a>)&gt; &amp;validator)</td></tr>
<tr class="memdesc:afb4b3a272e0f735d504c921b04fb56b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a message handler for the given message type, if no handler already exists. Messages for this message type will be validated using the given validator. The message handler is invoked iff the validator returns true for the json object. If a handler already exists, this method no-ops.  <a href="classwebsocket_1_1WebSocketProtocol.html#afb4b3a272e0f735d504c921b04fb56b3">More...</a><br /></td></tr>
<tr class="separator:afb4b3a272e0f735d504c921b04fb56b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b8652f2a1d5e85a6e857202ad1f003"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html#a89b8652f2a1d5e85a6e857202ad1f003">removeMessageHandler</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;messageType)</td></tr>
<tr class="memdesc:a89b8652f2a1d5e85a6e857202ad1f003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the message handler for the given message type, if it exists.  <a href="classwebsocket_1_1WebSocketProtocol.html#a89b8652f2a1d5e85a6e857202ad1f003">More...</a><br /></td></tr>
<tr class="separator:a89b8652f2a1d5e85a6e857202ad1f003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7892ad318af8fd69b7dc4e3062be3a2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html#a7892ad318af8fd69b7dc4e3062be3a2f">hasMessageHandler</a> (const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;messageType) const</td></tr>
<tr class="memdesc:a7892ad318af8fd69b7dc4e3062be3a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given message type has an associated message handler.  <a href="classwebsocket_1_1WebSocketProtocol.html#a7892ad318af8fd69b7dc4e3062be3a2f">More...</a><br /></td></tr>
<tr class="separator:a7892ad318af8fd69b7dc4e3062be3a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e2332a25714bae72c926adfc8c45da"><td class="memItemLeft" align="right" valign="top"><a id="a84e2332a25714bae72c926adfc8c45da" name="a84e2332a25714bae72c926adfc8c45da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addConnectionHandler</b> (const std::function&lt; void()&gt; &amp;handler)</td></tr>
<tr class="separator:a84e2332a25714bae72c926adfc8c45da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9680abdc89365aa217635cccfca2518c"><td class="memItemLeft" align="right" valign="top"><a id="a9680abdc89365aa217635cccfca2518c" name="a9680abdc89365aa217635cccfca2518c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addDisconnectionHandler</b> (const std::function&lt; void()&gt; &amp;handler)</td></tr>
<tr class="separator:a9680abdc89365aa217635cccfca2518c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe103259d04d555c6e1e754a65fa669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html#aebe103259d04d555c6e1e754a65fa669">processMessage</a> (const <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a> &amp;obj) const</td></tr>
<tr class="memdesc:aebe103259d04d555c6e1e754a65fa669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the given JSON object that was sent to this protocol's endpoint. Generally, this shouldn't be used by client code.  <a href="classwebsocket_1_1WebSocketProtocol.html#aebe103259d04d555c6e1e754a65fa669">More...</a><br /></td></tr>
<tr class="separator:aebe103259d04d555c6e1e754a65fa669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9eddefd7b71e535ba3df9f6cac5895d"><td class="memItemLeft" align="right" valign="top"><a id="af9eddefd7b71e535ba3df9f6cac5895d" name="af9eddefd7b71e535ba3df9f6cac5895d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clientConnected</b> ()</td></tr>
<tr class="memdesc:af9eddefd7b71e535ba3df9f6cac5895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all connection handlers for this protocol. Generally, this shouldn't be used by client code. <br /></td></tr>
<tr class="separator:af9eddefd7b71e535ba3df9f6cac5895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b1d0c8c640a5e7d861fa1ae27184b1"><td class="memItemLeft" align="right" valign="top"><a id="a73b1d0c8c640a5e7d861fa1ae27184b1" name="a73b1d0c8c640a5e7d861fa1ae27184b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clientDisconnected</b> ()</td></tr>
<tr class="memdesc:a73b1d0c8c640a5e7d861fa1ae27184b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all disconnection handlers for this protocol. Generally, this shouldn't be used by client code. <br /></td></tr>
<tr class="separator:a73b1d0c8c640a5e7d861fa1ae27184b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72711f7095f3b5a0edb352d4c4a6a89"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsocket_1_1WebSocketProtocol.html#ae72711f7095f3b5a0edb352d4c4a6a89">getProtocolPath</a> () const</td></tr>
<tr class="memdesc:ae72711f7095f3b5a0edb352d4c4a6a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the protocol path of the endpoint this protocol is served on.  <a href="classwebsocket_1_1WebSocketProtocol.html#ae72711f7095f3b5a0edb352d4c4a6a89">More...</a><br /></td></tr>
<tr class="separator:ae72711f7095f3b5a0edb352d4c4a6a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Defines a protocol which will be served at an endpoint of a server. This protocol defines several message types, and processes messages of those types, dispatching events to message handlers wherever necessary. </p>
<p >JSON messages must define a "type" key, which controls how messages are handled. Additionally, JSON messages must (obviously) conform the expectations of the message handlers. This can be verified at runtime by using the optional validation functionality. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a49126d6de1f4566a511d36109ff6abf4" name="a49126d6de1f4566a511d36109ff6abf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49126d6de1f4566a511d36109ff6abf4">&#9670;&nbsp;</a></span>WebSocketProtocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">websocket::WebSocketProtocol::WebSocketProtocol </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>protocolPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new WebSocket protocol. This object doesn't itself "do" anything, but users should register this object with a server, which will then handle dispatching events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocolPath</td><td>The resource path that this protocol should be served on. This should be of the form "/foo/bar", for example. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3869e34982bbc3de61c42c8329a655bc" name="a3869e34982bbc3de61c42c8329a655bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3869e34982bbc3de61c42c8329a655bc">&#9670;&nbsp;</a></span>addMessageHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool websocket::WebSocketProtocol::addMessageHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>messageType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a message handler for the given message type, if no handler already exists. Messages for this message type will not be validated. If a handler already exists, this method no-ops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageType</td><td>The name of the message type this handler is designed for. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will accept the json object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no handler already existed. false if a handler already exists. </dd></dl>

</div>
</div>
<a id="afb4b3a272e0f735d504c921b04fb56b3" name="afb4b3a272e0f735d504c921b04fb56b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4b3a272e0f735d504c921b04fb56b3">&#9670;&nbsp;</a></span>addMessageHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool websocket::WebSocketProtocol::addMessageHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>messageType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(<a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>validator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a message handler for the given message type, if no handler already exists. Messages for this message type will be validated using the given validator. The message handler is invoked iff the validator returns true for the json object. If a handler already exists, this method no-ops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageType</td><td>The name of the message type this handler is designed for. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function that will accept the json object. </td></tr>
    <tr><td class="paramname">validator</td><td>The validator function that validates the json object. Returns true iff the message is valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no handler already existed. false if a handler already exists. </dd></dl>

</div>
</div>
<a id="ae72711f7095f3b5a0edb352d4c4a6a89" name="ae72711f7095f3b5a0edb352d4c4a6a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72711f7095f3b5a0edb352d4c4a6a89">&#9670;&nbsp;</a></span>getProtocolPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> websocket::WebSocketProtocol::getProtocolPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the protocol path of the endpoint this protocol is served on. </p>
<dl class="section return"><dt>Returns</dt><dd>The protocol path, of the form "/foo/bar". </dd></dl>

</div>
</div>
<a id="a7892ad318af8fd69b7dc4e3062be3a2f" name="a7892ad318af8fd69b7dc4e3062be3a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7892ad318af8fd69b7dc4e3062be3a2f">&#9670;&nbsp;</a></span>hasMessageHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool websocket::WebSocketProtocol::hasMessageHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>messageType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given message type has an associated message handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageType</td><td>The name of the message to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a handler exists for this message type, false otherwise. </dd></dl>

</div>
</div>
<a id="aebe103259d04d555c6e1e754a65fa669" name="aebe103259d04d555c6e1e754a65fa669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe103259d04d555c6e1e754a65fa669">&#9670;&nbsp;</a></span>processMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void websocket::WebSocketProtocol::processMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://nlohmann.github.io/json/doxygen/classnlohmann_1_1basic__json.html">json</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the given JSON object that was sent to this protocol's endpoint. Generally, this shouldn't be used by client code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The JSON object to be processed by this protocol. It is expected to have a "type" key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89b8652f2a1d5e85a6e857202ad1f003" name="a89b8652f2a1d5e85a6e857202ad1f003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b8652f2a1d5e85a6e857202ad1f003">&#9670;&nbsp;</a></span>removeMessageHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool websocket::WebSocketProtocol::removeMessageHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gcc.gnu.org/onlinedocs/gcc-9.3.0/libstdc++/api/a01516.html#gaa5dbcd13c2fb305025ac6784482d05a5">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>messageType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the message handler for the given message type, if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageType</td><td>The name of the message type to remove the handler for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a handler existed for this message type and was removed, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Networking/websocket/<a class="el" href="WebSocketProtocol_8h_source.html">WebSocketProtocol.h</a></li>
<li>src/Networking/websocket/WebSocketProtocol.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
